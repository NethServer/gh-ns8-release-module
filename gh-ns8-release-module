#!/usr/bin/env bash

# Enable debugging and logging of shell operations
if [ -n "$DEBUG" ]; then
set -x
PS4='+${LINENO}: '
fi

source "$(dirname "$(readlink -f "$0")")/functions.sh"

# Function to display usage instructions
function usage() {
  echo "Usage: $0 [create|check|comment|clean] --repo <repo-name> [options]"
  echo ""
  echo "Options:"
  echo "  --repo <repo-name>         The GitHub NethServer 8 module repository (e.g., owner/ns8-module)."
  echo "  --release-refs <commit-sha> Commit SHA to associate with the release."
  echo "  --release-name <name>      Specify the release name (must follow semver format)."
  echo "  --testing                  Create a testing release."
  echo "  --draft                    Create a draft release."
  echo "  -h, --help                 Display this help message."
  exit 1
}

# The first argument must be `create`, `check`, `comment`, or `clean`
if [[ "$1" =~ ^(create|check|comment|clean)$ ]]; then
  subcommand=$1
  shift
else
  echo 'The first argument must be `create`, `check`, `comment`, or `clean`'
  usage
fi

testing_arg=0
# Parse command line arguments
while [ $# -gt 0 ]; do
  case "$1" in
  --repo)
    repo_arg="$2"
    shift
    ;;
  --release-refs)
    release_refs_arg="$2"
    shift
    ;;
  --release-name)
    release_name_arg="$2"
    shift
    ;;
  --testing)
    testing_arg=1
    ;;
  --draft)
    draft_arg="--draft"
    ;;
  -h|--help)
    usage
    ;;
  *)
    echo "Unknown argument: $1"
    usage
    ;;
  esac
  shift
done

#If the argument `--repo` is not provided, get the repo from the current directory
if [ -z "$repo_arg" ]; then
  repo_arg=$(gh repo view --json owner,name --jq '.owner.login + "/" + .name')
  if [ -z "$repo_arg" ]; then
    echo "Could not determine the repo. Please provide the repo name using the --repo flag"
    exit 1
  fi
fi

#Check if the repo is a valid github repo, using the gh api
gh api repos/$repo_arg 2>&1 > /dev/null
if [ $? -ne 0 ]; then
  echo "Invalid repo: $repo_arg"
  exit 1
fi

# Check the repository has a valid NS8 module name in the format `owner/ns8-<module-name>`
if ! echo $repo_arg | grep -qE '^[^/]+/ns8-'; then
  echo "Invalid NS8 module name: $repo_arg"
  exit 1
fi

#If the argument `--release-refs` is not provided, get the latest commit of the default branch
if [ -z "$release_refs_arg" ]; then
  release_refs_arg=$(gh api repos/$repo_arg/commits --jq '.[0].sha')
  if [ -z "$release_refs_arg" ]; then
    echo "Could not determine the latest commit sha. Please provide the commit sha using the --release-refs flag"
    exit 1
  fi
else
  #Check if the commit sha is on the default branch
  default_branch=$(gh repo view --repo $repo_arg --json defaultBranchRef -q ".defaultBranchRef.name")
  commit_branch=$(gh api repos/$repo_arg/commits/$release_refs_arg/branches-where-head --jq '.[].name | select(. == $default_branch)' --arg default_branch $default_branch)
  if [ -z "$commit_branch" ]; then
    echo "The commit sha is not on the default branch: $default_branch"
    exit 1
  fi
  target="--target $release_refs_arg"
fi

# If the argument `--testing` is not provided then the `--release-name` argument must be present
if [ $testing_arg == 0 ] && [ -z "$release_name_arg" ] && [ $subcommand != "check" ] && [ $subcommand != "clean" ]; then
  echo "Please provide the release name using the --release-name flag"
  exit 1
fi

# If the argument `--release-name` is provided check if the release name is in
# valid semver format
if [ ! -z "$release_name_arg" ]; then
  if ! is_semver $release_name_arg; then
    echo "Invalid semver format for release name"
    exit 1
  fi
fi


# Check if the subcommand is `create`, `check`, `comment`, or `clean`
if [ "$subcommand" == "create" ]; then
  # Create a new release

  release_name=$release_name_arg

  if [[ "$testing_arg" == 1 || "$release_name" =~ - ]]; then
    prerelease="--prerelease"
    if [ -z "$release_name_arg" ]; then
      release_name=$(next_testing_release $repo_arg)
      if [ "$?" -eq 1  ]; then
        echo $release_name
        exit 1
      fi
    fi
  fi

  gh release create $draft_arg $target $prerelease --repo $repo_arg --title $release_name --generate-notes $release_name

elif [ "$subcommand" == "check" ]; then
  # Get the name the latest release that is not a prerelease
  latest_release=$(gh release list --repo $repo_arg --exclude-pre-releases --json tagName --limit 1 --order desc --jq '.[0].tagName')

  # Get the commit sha for the latest releases
  latest_release_sha=$(gh api repos/$repo_arg/git/ref/tags/$latest_release --jq '.object.sha')

  # Check if there are changes to release
  check_if_release_needed() {
    local repo=$1
    local latest_release_sha=$2

    # Check if the latest release tag is the HEAD of the main branches
    if [ "$latest_release_sha" == "$(gh api repos/$repo/git/ref/heads/main --jq '.object.sha')" ]; then
      echo "The latest release tag is the HEAD of the main branch, there is nothing to release"
      return 1
    fi
    return 0
  }

  # Process issue data and store in associative arrays
  process_issue() {
    local repo=$1
    local issue=$2

    # Skip if we've already processed this issue
    if [ ! -z "${processed_issues[$issue]}" ]; then
      # Just increment reference counter
      issue_refs[$issue]=$((${issue_refs[$issue]:-0} + 1))
      return
    fi

    processed_issues[$issue]=1
    # Increment reference counter
    issue_refs[$issue]=$((${issue_refs[$issue]:-0} + 1))

    local parent=$(get_parent_issue_number "$repo" $issue)
    if [ ! -z "$parent" ]; then
      # This is a child issue
      child_issues[$parent]+="$issue "
      # Store parent's info if we haven't already
      if [ -z "${processed_issues[$parent]}" ]; then
        processed_issues[$parent]=1
        parent_issues[$parent]=1
        update_issue_metadata "$repo" $parent
      fi
    else
      # This is a parent or standalone issue
      parent_issues[$issue]=1
    fi

    # Store issue info regardless of parent/child status
    update_issue_metadata "$repo" $issue
  }

  # Update metadata for a single issue
  update_issue_metadata() {
    local repo=$1
    local issue=$2

    local all_labels=$(get_issue_labels "$repo" $issue)
    issue_labels[$issue]=$(echo "$all_labels" | sed -e 's/testing//g' -e 's/verified//g' | xargs)
    issue_status[$issue]=$(is_issue_closed "$repo" $issue && echo "ðŸŸ£" || echo "ðŸŸ¢")

    # Check progress status
    if echo "$all_labels" | grep -q "verified"; then
      issue_progress[$issue]="âœ…"
    elif echo "$all_labels" | grep -q "testing"; then
      issue_progress[$issue]="ðŸ”¨"
    else
      issue_progress[$issue]="ðŸš§"
    fi
  }

  # Process all PRs and collect issue information
  process_prs_and_collect_issues() {
    local repo=$1
    local latest_release=$2

    local prs=$(scan_for_prs $repo $latest_release main)
    if [ "$?" -ne 0 ]; then
      return 1
    fi

    for pr in $prs; do
      local linked=$(get_linked_issues $repo $pr)
      if [ "$?" -ne 0 ]; then
        # Handle translation and unlinked PRs
        local has_translation=$(gh api repos/$repo/pulls/$pr --jq '[.labels[].name] | any(. == "translation")')
        if [ "$has_translation" = "true" ]; then
          translation_prs="${translation_prs}https://github.com/$repo/pull/$pr\n"
        else
          unlinked_prs="${unlinked_prs}https://github.com/$repo/pull/$pr\n"
        fi
      else
        for issue in $linked; do
          process_issue "NethServer/dev" $issue
        done
      fi
    done
    return 0
  }

  # Display summary information
  display_summary() {
    echo "Summary:"
    echo "--------"
    if [ ! -z "$unlinked_prs" ]; then
      echo -e "\033[33mPRs without linked issues:\033[0m"
      echo -e "$unlinked_prs"
    fi

    if [ ! -z "$translation_prs" ]; then
      echo -e "\033[36mTranslation PRs:\033[0m"
      echo -e "$translation_prs"
    fi

    echo -e "\033[1mIssues:\033[0m"

    # First, display parent issues with their children
    display_parent_issues

    # Display standalone issues
    display_standalone_issues

    # Check for any issues not in verified status
    local all_verified=true
    # First check all child issues are verified
    for parent in "${!child_issues[@]}"; do
      for child in ${child_issues[$parent]}; do
        if [[ "${issue_progress[$child]}" != "âœ…" ]]; then
          all_verified=false
          break 2
        fi
      done
    done

    # Then check parent issues without child issues
    for issue in "${!issue_progress[@]}"; do
      # Skip parent issues with children as we'll check children separately
      if [ ! -z "${child_issues[$issue]}" ]; then
        continue
      fi
      if [[ "${issue_progress[$issue]}" != "âœ…" ]]; then
        all_verified=false
        break
      fi
    done

    if [ -z "$unlinked_prs" ] && $all_verified; then
      echo
      echo -e "\033[32mâœ… All checks passed! Ready to release.\033[0m"
    fi

    # Print legend
    echo "---"
    echo "Issue status:    ðŸŸ¢ Open    ðŸŸ£ Closed"
    echo "Progress status: ðŸš§ In Progress    ðŸ”¨ Testing    âœ… Verified"
  }

  # Display parent issues with their children
  display_parent_issues() {
    for parent in "${!parent_issues[@]}"; do
      # Skip if this is actually a child issue
      if [ ! -z "$(echo "${child_issues[@]}" | grep -w "$parent")" ]; then
        continue
      fi

      ref_display="${issue_refs[$parent]:-0}"
      printf "%-6s %s %-45s (%s) %s\n" "${issue_status[$parent]}" "${issue_progress[$parent]}" "https://github.com/NethServer/dev/issues/$parent" "$ref_display" "${issue_labels[$parent]}"

      if [ ! -z "${child_issues[$parent]}" ]; then
        for child in ${child_issues[$parent]}; do
          child_ref_display="${issue_refs[$child]:-0}"
          printf "%-2s%-2s %s %-45s (%s) %s\n" "â””â”€" "${issue_status[$child]}" "${issue_progress[$child]}" "https://github.com/NethServer/dev/issues/$child" "$child_ref_display" "${issue_labels[$child]}"
        done
      fi
    done
  }

  # Display standalone issues (no parent or children)
  display_standalone_issues() {
    for issue in "${!issue_labels[@]}"; do
      # Skip if this is a parent or child issue
      if [ ! -z "${child_issues[$issue]}" ] || [ ! -z "$(echo "${child_issues[@]}" | grep -w "$issue")" ]; then
        continue
      fi
      if [ -z "${parent_issues[$issue]}" ]; then
        ref_display="${issue_refs[$issue]:-0}"
        printf "%-6s %s %-45s (%s) %s\n" "${issue_status[$issue]}" "${issue_progress[$issue]}" "https://github.com/NethServer/dev/issues/$issue" "$ref_display" "${issue_labels[$issue]}"
      fi
    done
  }

  # Main execution for check command
  check_command_main() {
    # Initialize arrays
    unlinked_prs=""
    translation_prs=""
    declare -A parent_issues
    declare -A child_issues
    declare -A issue_labels
    declare -A issue_status
    declare -A issue_progress
    declare -A issue_refs
    declare -A processed_issues

    echo "Checking PRs and issues since $latest_release..."
    echo ""

    if [ -z "$latest_release" ]; then
      echo "No releases found."
      return 1
    fi

    if ! check_if_release_needed "$repo_arg" "$latest_release_sha"; then
      return 1
    fi

    if ! process_prs_and_collect_issues "$repo_arg" "$latest_release"; then
      echo "Error processing PRs."
      return 1
    fi

    display_summary
    return 0
  }

  # Execute main function for check command
  check_command_main

elif [ "$subcommand" == "comment" ]; then

  # If the argument `--release-name` is not provided, get the name the latest release
  if [ -z "$release_name_arg" ]; then
    # Get the name the latest release
    release_name_arg=$(gh release list  --repo $repo_arg --json tagName --limit 1 --order desc  --jq '.[0].tagName')
  fi

  create_comment $repo_arg $release_name_arg

elif [ "$subcommand" == "clean" ]; then

  # If no stable release is provided, get the latest stable release
  if [ -z "$release_name_arg" ]; then
    release_name_arg=$(gh release list --repo $repo_arg --exclude-pre-releases --json tagName --limit 1 --order desc --jq '.[0].tagName')
    if [ -z "$release_name_arg" ]; then
      echo "No stable release found in the repository."
      exit 1
    fi
  fi

  clean_releases $repo_arg $release_name_arg

fi
